#### 一、八大算法思想
1. 枚举: 百钱买百鸡问题 (最符合人的思维逻辑，即一般的暴力解法)
2. 递推: 兔子问题 (跟迭代什么区别？？？)
3. 递归: 汉诺塔问题 (重复调用自身，效率底且有栈溢出风险，但是代码简洁易读)
4. 分治: 归并排序 (先分再治)
5. 动态规划: 背包问题 (最优子结构; 无后效性)
6. 贪心: 旅行推销员问题 (局部最优解)
7. 回溯: 八皇后问题 (需要穷举整棵决策树，效率不高，常用语树、图或者棋盘等的遍历)
8. 模拟

### 二、其他几种解体思路
1. 双指针
双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。
换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。

(1) 对撞指针
对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。
对撞数组适用于有序数组，也就是说当你遇到题目给定有序数组时，应该第一时间想到用对撞指针解题。
伪代码：
```
function fn (list) {
    var left = 0;
    var right = list.length - 1;
    
    //遍历数组
    // 如果左右指针可以相等这里就<=，如果不能相等就<
    while (left <= right) {
        left++;
        // 一些条件判断 和处理
        ...
        right--;
    }
}
```

(2) 快慢指针
快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow）。
两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。



